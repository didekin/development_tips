FILES
====================================

LOAD
----

--  Para cargar los datos que vienen en la distribución estándar de R:
    > library(datasets)
    > data(iris)

--  To download a file:
    > fileUrl <- "https://...."
    > download.file(fileUrl, destfile = "./data/f.csv", method = "curl")

--  To load a CSV file
    > library(readr)
    > titular_old <- read_csv(
        "~/Documents/clientes/leben/demo_dic_2018/data/titular_old.csv",
        col_names = c(
        "titular_id","acumula_num_tx","acumula_ptos","pedido_num_tx","pedido_ptos","fraccion_disp","avg_redencion"
        ),
        col_types = cols(
        titular_id = col_integer(),
        acumula_num_tx = col_integer(),
        acumula_ptos = col_integer(),
        pedido_num_tx = col_integer(),
        pedido_ptos = col_integer(),
        fraccion_disp = col_double(),
        avg_redencion = col_integer()
        )
      )

--  To check the variable names of the loaded file:
    > names(variable)
--  To make the variables in this data frame available by name
    > attach(dataSet)
    OR we must type the data set and the variable name joined with a $ symbol

--  To load a "flat" file local:
    > read.table("path")

--  To  load an Excel file:
    > library(xlsx)
    > read.xlsx("path",sheetIndex=1,header=TRUE)

--  To  parse a remote JSON file:
    > library(jsonlite)
    > jsonData <- fromJSON("https://api.github.com/users/jtleek/repos")

--  To  write a data.frame to a JSON file:
    > myjson <- toJSON(iris, pretty=TRUE)
--  To  convert back to JSON:
    > iris2 <- fromJSON(myjson)

MANIPULATE
----------

--  To  read a file or a connection object:
    > readLines(connection,..)
--  To  count the number of character in a line:
    > nchar(line)

MYSQL
====================================

--  To install package on Mac:
    > install.packages("RMySQL")
--  To  connect to a server and database:
    > conn <- dbConnect(MySQL(),user="pedro",password="pedro",dbname="leben",host="localhost",client.flag=CLIENT_MULTI_RESULTS)
--  To execute a query:
    > datasetName <- dbGetQuery(conn, queryTx1Str)
--  To close the connection:
    > dbDisconnect(conn)

--  To see data in a spreadsheet window:
    > View(datasetName)
    > fix(datasetName)
--  To inspect the data:
    > dim(datasetName)
    > names(datasetName)
    > str(datasetName)

FACTORS
=======

--  To convert quantitative variables into qualitative variables:
    > newFactoVar = as.factor(oldVar)
    
--  To discretise continuous variables:
    > cut(..)

NA
==

--  To filter rows with NA values:
    > dataset[complete.cases(dataset),]
    > summarise(mean = mean(columnName, na.rm = TRUE))
    
--  To select rows with a logical conditions and to avoid NA values:
    > x[which(x$var2 >=9),]
--  To filter rows with NA values in certain columns:
    > dataset[complete.cases(dataset[,i:j]),]
    > filter(!is.na(columName1), !is.na(columnName2))

--  To know the NA values in a column:
    > sum(is.na(columnName))
    > (sum(!is.na(columName)))
    Or to know if there is NA values in a column:
    > any(is.na(columName))
--  To know the number of NA occurrences in each column of a data set:
    > colSums(is.na(dataSetName))
--  To validate the existence of NA values in the data set.
    > all(colSums(is.na(dataSetName)) ==0)

    More on calculating NA values in a column, in tabular form:
    > pid$isNaJWMNP <- ifelse(is.na(pid$JWMNP),TRUE,FALSE)
    > table(pid$isNaJWMNP,is.na(pid$JWMNP))

--  To validate the full set of values of a column:
    > all(pid$WKHP > 0)

--  To sort puttind NA values at the end of the vector:
    > sort(x$var2,na.last=T)
    
--  To replace NA values in whole dataset:

    > mutate_all(funs(replace(., is.na(.), 0)))

    Locationally:
    > mutate_at(c(5:10), funs(replace(., is.na(.), 0)))
    > mutate_at(vars(var5:var10), funs(replace(., is.na(.), 0)))
    
    Conditionally (change just numeric columns):
    > mutate_if(is.integer, funs(replace(., is.na(.), 0)))
    > mutate_if(is.numeric, funs(replace(., is.na(.), 0)))
    
--  To complete all the combinations of a set of categorical variables, with NA for non existent combination-values:
    complete(variableName1, variableName2)
    
OBJECTS - VARIABLES
====================================

--  To see the description of an object.
    > str(object)
--  To know the storage mode of any object:
    typeof(objectName)
--  Similar in an object oriented context:
    class(objectName)
--  To get the memory footprint of several objects:
    pryr::object_size(objName1, objName2, ...)
--  To see the attributes of an object:
    > attributes(objectName)
--  To 'unclass' an object:
    > unclass(objectName)
    
TIBBLES - DATA FRAMES
=====================

--  To pull out a single variable (column)
    > dataframName[["variableName"]] or dataframName[[position]]
    > pull(dataFrame, var = ?) # var may be a literal name, a positive or a negative integer.
    Inside a pipe, dataframe uses a placeholder '.':
    > .[["variableName"]] or .[[position]]

--  To recode the value of a variable:
    > dataFrameName$varName[dataFrameName$varName == 99] <- NA
--  To create a new variable from an already variable in a data frame (dataFrameName):
    > dataFrameName <- within(dataFrameName,{
                     newVarName <- NA
                     newVarName[oldVarName > 75]              <- "Elder"
                     newVarName[oldVarName >= 55 & age <= 75] <- "Middle Aged"
                     newVarNameoldVarName < 55]              <- "Young" })
--  To create a dataFrame from a selection of values of an old one: 
    # Selecciona, para las filas que cumplen los criterios, todas las columnas.
    > newDataFrameName <- dataFrameName[which(dataFrameName$var1Name=="M" &
                                    dataFrameName$var2Name > 30),]  
    
--  To coerce a tibble to a data frame:
    as.data.frame(tibbleName)
    
--  To get a simple table with a label and frequency count of occurrences in a column:
    > count(dataFrameName, columnName)
--  T count the occurrences into equally spaced bins:
    > count(cut_width(variableName, 0.5))   # 0.5 is the space interval.

--  To add a primery key to a dataframe:
    mutate(
        pk = row_number()
    )
    
--  To discretise continuous variables:
    > cut(..)
    
--  To combine data frames:
    > bind_rows(...), bind_cols(...), combine(...)
    
--  To produce a numerical summary of each variable in a particular data set.
    > summary(mtcars)

VECTOR - LIST - MATRICES
====================================

--  NULL is often used to represent the absence of a vector.
--  NA is used to represent the absence of a value in a vector.

VECTOR
------

--  To create vectors with sequence of numbers:
    > seq(0,1,length=10)   # 0.0000000 0.1111111 0.2222222 0.3333333 0.4444444 0.5555556 0.6666667 0.7777778 0.8888889 1.0000000
    > x = 0:1    # 0 1
--  To create a vector with repeated values from another vector:
    > c("a","b")
    > [c(1,2,1,2,1,1)]
      [1] "a" "b" "a" "b" "a" "a"
    
--  Para definir un índice negativo, se define un vector -c(..) con las posiciones a excluir.
    > A[-c(1,3),]  
    > A[-c(1,3),-c(1,3,4)]  // All but rows 1 and 3, and columns 1,3, and 4.
--  Negative values drop the elements at the specified positions.
    It’s an error to mix positive and negative values.
    > x[c(-1, -3, -5)]

--  Subsetting with a logical vector keeps all values corresponding to a TRUE value:
    > x[x %% 2 == 0]  # All even (or missing!) values of x
--  To subset a named vector:
    > x[c("colName1", "colNameX")]
    
LIST
----
--  '[' extracts a sub-list. The result will always be a list.
--  '[[' extracts a single component from a list. It removes a level of hierarchy from the list.
--  '$' is a shorthand for extracting named elements of a list. You don’t need to use quotes.

--  To remove a level hierarchy from a list:
    > purrr::flatten(x)
    > unlist(x)
    
MATRIX
------
    
--  To create a matrix:
    > A = matrix(1:10,nr=5,nc=2)
    By default R creates matrices by successively filling in columns:
    > x=matrix(c(1,2,3,4) ,2,2)   // a 2x2 matrix.
    1   3
    2   4

--  To get the number of rows or columns:
    > nrow(dataset), ncol(dataset)
    Para dataframes y vectores, también: NCOL y NROW.
    
--  To select the element corresponding to the second row and the third column in a matrix:
    > A[2,3]
    > datasetName["2", "num_titulares"]
--  To select multiple rows and columns at a time,we provide vectors as the indices.
    > A[c(1,3),c(2,4)]
    > A[1:3,2:4]
    > A [1:2 ,]   // rows 1 and 2, all columns
    > A [ ,1:2]   // all rows, columns 1 and 2
    > datasetName[datasetName$tx_year == 2010, 2:5]






