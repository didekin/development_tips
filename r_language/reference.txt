LANGUAGE REFERENCE
==================

Control flow
------------
`repeat' initiates an infinite loop.
'next' is used to skip an iteration of a loop.
'return' signals that a function should exist and return a given value.

Functions
---------

Functions can be passed as arguments to other functions.
They can be nested.
The return value of a function is the last expression in the function body to be evaluated.

Example of nested function return from the parent:

make.power <- function(n) {
        pow <- function(x) {
                x^n
        }
        pow
}

>cube <- make.power(3)
>cube(2)
[1] 8

The 'formals' function returns a list of all the formal arguments of a function. 'args' is similar.

When an argument is matched by name, it is “taken out” of the argument list and the remaining unnamed arguments are matched in the order that they are listed in the function definition. Example:

lm(data = mydata, y ~ x, model = FALSE, 1:100)
lm(y ~ x, mydata, 1:100, model = FALSE)

Arguments are evaluated only as needed:

f <- function(a, b) {
    a^2
}

>f(2)
> [1] 4

Any arguments that appear after ... on the argument list must be named explicitly and cannot be partially matched.

To select a function with the samen name in two different packages, we use the package and '::', as in:
>json2 = jsonlite::fromJSON(toJSON(json1))

To see an example of a function:
>example(function)

Scoping
-------
When you are working on the command line and need to retrieve the value of an R object, the order is roughly:
1. Search the global environment for a symbol name matching the one requested.
2. Search the namespaces of each of the packages on the search list.

'search()' returns the search list.

When a user loads a package with library the namespace of that package gets put in position 2 of the search list (by default) and everything else gets shifted down the list.
Note that R has separate namespaces for functions and non-functions so it’s possible to have an object named c and a function named c.

To get the environment of a function:
>ls(environment(cube))
[1] "n"   "pow"
> get("n", environment(cube))
[1] 3

To get the current (definition) environment: environment().
To get the parent environment: parent.env(environment).
To get the frame (calling environment): parent.frame().

Dates
-----
POSIXct is just a very large integer under the hood.
POSIXlt is a list underneath and it stores a bunch of other useful information like the day of the week, day of the year, month, day of the month.

Dates are represented by the Date class: 'as.Date(string)'.
'weekdays': gives the day of the week.
'months': gives the month name.
'quarters': gives the quarter number.

>x <- Sys.time()
>x
[1] "2013-01-24 22:04:14 EST"  # POSIXct.
>p <- as.POSIXlt(x)
>names(unclass(p))
[1] "sec"   "min"   "hour"  "mday"  "mon"
[6] "year"  "wday"  "yday"  "isdst"
>p$sec
[1] 14.34

There is the 'strptime()' function in case your dates are written in a different format.