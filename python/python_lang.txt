CHARACTERS
==========

--  To see the default encoding:
    > sys.getdefaultencoding()

CLASSES-OBJECTS
===============

--  To know the type of an object:
    > type(object)
    > isinstance(23,int)
--  Multiple assignment:
    > x, y = 2, 3
    > x, y = y, x

--  To define an empty class:
    > class Foo:
          pass

COLLECTIONS
===========

--  All indexing in a sequence is zero-based.
--  To copy a list:
    > newList = oldlist[:]
--  To create an empty list:
    > emptyList = []
--  The operators in and not in test for collection membership:
    > element in col_A
    > element not in col_A
    > not (element in col_A)

--  Not index out bounds exception in slicing, even if the first and the last index are both out of range:
    > 'abcdefghijk'[11:20] --> ''
--  Reverse order
    > 'abcdefghijk'[-10:-7] -->'bcd'
    > 'abcdefghijk'[:-3] --> 'abcdefgh'
    > 'abcdefghijk'[2:0:-1] --> 'cb'

--  Append et extend modifient la liste sur laquelle elles travaillent, alors que l'addition (+) crée un nouvel objet.
--  On peut toujours réaliser l'addition sur tous les types séquences, puisqu'on crée un nouvel objet pour stocker le résultat de l'addition.
    Mais append et extend ne sont par exemple pas disponibles sur les chaînes de caractères, qui sont immuables.
--  list.insert(index, [values]) is equivalent to list[index:index] = [values]

--  List comprehension:
    [expr for elem in iterable if test]
    L = [(x, y)
       for x in range(6) if x%2 == 0
       for y in range(6) if y%3 == 0]

--  Dictionnary comprehension
    {key: value for id1, id2 in iterable if test}
    {w: d for d, w in number_to_word.items() if d < 10}
    gen_code_keys = (lambda book, plain_text:({c: str(book.find(c)) for c in plain_text}))
    // where gen_code_keys is a funtction with parameters book, plain_text and returns c.

CONTROL FLOW
============

--  Conditional expressions: expr1 if condition else expr2
    > print((x if x > z else z) if x > y else (y if y > z else z))  # OR
    > x = y if y > z else z
--  To define an empty loop:
    > while liste.pop() != 5:
          pass

EDITION
=======

--  To tell Python which encoding to use, insert a comment of the form # -*- coding: encoding name -*-
    as the first or second line of your program:
    > # -*- coding: utf-8 -*-

--  To multiline comment:
    > """
      """
--  To break a long line:
    -   Ending each line on the screen, other than the last one, with a backslash (\)
    -   Wrapping the whole line ith bracketing, i.e., parentheses, square brackets, and braces, and putting a '+'
        at the end of each piece of the line.

EXCEPTIONS
==========



EXECUTION (with INPUTS)
=======================

--  To run a program directly in the console:
    > python3 trash.py  // in the directory of trash.py
--  To run a selection of source code from the Pycharm editor in console:
    shortcut: ^ + SHIFT + E
--  To run file in console:
    > ^ + ENTER

--  To ask interactively a user to enter a value:
    >   nom_ville = input("Entrez le nom de la ville : ")
--  To run a program passing arguments to it:
    -- ArgumentParser from module argparse

FILES
=====

--  To read or (binary) write a file with context manager:
    > with open(r'C:\temp\spam.txt', 'r', encoding= 'utf8') as f:
        <bloc of instructions>
    > with open(r'C:\temp\spam.bin', 'bw') as f: // bw --> binary write.
--  To add the content to a file:
    > with open("foo.txt", "a", encoding='utf-8') as sortie:  // a --> add to the end.
--  Un fichier est son propre itérateur:
    > with open("foo.txt", encoding='utf-8') as entree:
          print(entree.__iter__() is entree)

--  To change the terminal stdout to a discretinary file:
    > import sys
    > autre_stdout = open('ma_sortie.txt', 'w', encoding='utf-8')

--  Built-in function 'repr':
    > lines = "abc" + "\n" + "def"  + "\n"
    > print(repr(lines))  // --> 'abc\ndef\n'

--  To manipulate paths:
    > from pathlib import Path
    > path = Path("files/myfile.txt")
--  To find all json files in a dir:
    > dirpath = Path('./data/')
    > for json in dirpath.glob("*.json"): ...

FUNCTIONS
=========

--  Lambdas:
    lambda <sequence of variable names> : <expression>
    lambda x, y: x*y
--  To define an empty function:
    > def foo():
          pass

HELP
====

--  In ipython and notebook:
    >str?  // p.e.
--  To get interactive help in the console:
    > help()
    To exit:
    > quit
--  To get help about a particular function:
    > help(nameFunction)
    > help(math.ceil)  // function in module math
--  To get help about a method:
    > help(list.sort)


MODULES
=======

--  To  import a module:
    > import math
--  To see the functions in a module
    > dir(math)

NUMBERS
=======

--  When a float is converted to an int, the number is truncated (not rounded).
--  Complex number:
    > 2 + 2j
    > 2 + 2.j
    > 2 + 2*1.j

OPERATORS
=========

--  '*' operator for iterable unpacking:
    > a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    > x, *y = a
    > y = [1, 2, 3, 4, 5, 6, 7, 8, 9]
    Conversely:
    > *x, y = a
    > x = [0, 1, 2, 3, 4, 5, 6, 7, 8]

--  i to the power j:
    > i ** j
--  Floor division:
    > i//j

--  Negative boolean 'not'
    > not mybooleanValue
--  Other operators on type bool: 'and', 'or'.

PRINTING
========

--  print(...) insert the spaces betweeen the arguments passed.
--  print(...) by default insert a new line character at the end of the arguments. To avoid this, an 'end' argument can be passed.

--  To inline variables in text:
    >   print(f"hello, {expression}")  # The expression can be result of calling a function.
        On peut ajouter le f devant toutes les formes de strings, qu'ils commencent par ' ou " ou ''' ou """.
    > print ("Add 10 to 12 and 14, and get %s and %s" % (twentytwo, twentyfour)) # twentytwo, twentyfour are vars. The final % is the operator.
    > print("log(x): ", pylab.log(x))

--  To include a curly brace in the string denoted by an f-string use two braces:
    > print(f'{{{3*5}}}')   # prints {15}.
--  The expression inside an f-string can contain modifiers that control the appearance of the output string.
    These modifiers are separated from the expression denoting the value to be modified by a colon (:).
    > f'{3.14159:.2f}'  # evaluates to '3.14'
    Pour forcer un petit entier à s'afficher sur 4 caractères, avec des 0 ajoutés au début si nécessaire:
    >   f"{x:04d}"  // if x = 15, then print(f"{x:04d}") -> '0015'
    Pour n'obtenir que l'heure et la minute d'un objet datetime:
    >   f"{mtime_datetime:%H:%M}"

--  To print a number with a ',' thousand separator: (problems with a . separator)
    > print(f"z:,")  # z is a float number.

REGULAR EXPRESSIONS
===================

--  Module re
    >   import re
--  Pour savoir si un objet chaine est ou non de la forme *-*.txt
    >   regexp = "(.*)-(.*)\.txt"
--  re.match(regexp, sample)  ⟺  re.compile(regexp).match(sample)

--  Pour chercher tous les mots se terminant par 'a' ou 'm' dans une chaîne:
    >   print(re.findall(r"\w*[am]\W", sentence))
--  L'attrape-tout '.' en fait n'attrape pas le caractère de fin de ligne \n. Il existe un flag re.DOTALL qui permet de
    faire de '.' un vrai attrape-tout qui capture aussi les newline
    Or pour l'ajouter explicitement:
    > match = re.compile("([\w \n]*)", flags=re.UNICODE).match(sample)

GROUPS
--  Pour l'accès par rang aux groups, les indices commencent à 1.
--  (...) les parenthèses définissent un groupe anonyme.
--  (?P<name>...) définit un groupe nommé
--  (?:...) permet de mettre des parenthèses mais sans créer un groupe.
--  (?P=name) ne matche que si l'on retrouve à cet endroit de l'entrée la même sous-chaîne que celle trouvée pour le groupe name en amont.
--  Pour ajouter comme contrainte que le premier et le dernier groupes de chiffres soient identiques:
    >   regexp3 = "(?P<id>[0-9]+)[A-Za-z]+(?P<needle>[0-9]+)[A-Za-z]+(?P=id)"

STRINGS
=======

--  To concatenate string varibles with spaces in between:
    > print(var1,var2)
--  To concatenate without spaces:
    > print(var1 + var 2)
    > "abc"  "def" // quand deux chaînes apparaissent immédiatement l'une après l'autre sans opérateur, elles sont concaténées.
    > print(f"pour n = {test:2d} : premier → {premier(test)}\n"
          f" premier_sans_else → {premier_sans_else(test)}\n")
--  To repeat a string a number of times
    > varstringA * number   // "hola" * 5

--  To cast a number, p.e., to a string:
    > str(5)

--  Negative numbers are used to index from the end of a string.
    > 'abc'[‐1] # is 'c'.
--  To reverse a string with all its characters:
    > varstring[::-1]
--  The expression 'abc'[:] is semantically equivalent to 'abc'[0:len('abc')]

--  To check if a sequence of characters is a string:
    > "def" in "abcdefcdefghefghijk"
--  To iterate over characters of a string:
    > for ch in 'ad123fg': ...

TUPLES
======

--  To create a tuple with one element:
    > t = (4,)  or t = 4,
--  To convert a tuple in a list:
    > l = list(t)
--  To convert a list in a tuple:
    > t2 = tuple(l)

--  To change to variables:
    > a = 1
    > b = 2
    > a, b = b, a

--  UNPACKING
    > liste = [1, 2, 3]
    > gauche, milieu, droit = liste  or [gauche, milieu, droit] = list

    --  '*' operator for iterable unpacking:
    > a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    > x, *y = a
    > y = [1, 2, 3, 4, 5, 6, 7, 8, 9]
    Conversely:
    > *x, y = a
    > x = [0, 1, 2, 3, 4, 5, 6, 7, 8]




