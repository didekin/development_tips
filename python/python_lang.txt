CLASSES-OBJECTS ASSIGNMENTS
===========================

--  To define an empty class:
    > class Foo:
          pass

--  To know the type of an object:
    > type(object)
    > isinstance(23,int)
    > isinstance(myarg, (tuple, list))
--  L'opérateur 'is' permet de savoir si deux valeurs correspondent au même objet en mémoire.
    > a is b
    La fonction id() retourne un identificateur unique pour chaque objet; un modèle mental acceptable est celui d'adresse mémoire.
    (a is b)  ⟺  (id(a) == id(b))

--  Pour annuler la définition d'une variable:
    > del varname
    > del listname[2:10:3]  // liste
    > del d['a']  // dictionnaire
    > del listname[2:10:3], d['a']  // plusieurs arguments

--  Multiple assignment:
    > x, y = 2, 3
    > x, y = y, x
--  Pour affecter le même objet à plusieurs variables:
    > a = b= 'hola'
--  La sémantique de '+=' est différente suivant que l'objet référencé par le terme de gauche est mutable ou immuable.
    > a = b = [] // a += [1]  // print(a) --> [1], print(b) --> [1]
    > a = b = 1  // a += 1  // print(a) --> 2, print(b) --> 1

CONTROL FLOW
============

--  CONDITIONAL EXPRESSIONS: expr1 if condition else expr2  or <résultat_si_vrai> if <condition> else <résultat_si_faux>
    > print((x if x > z else z) if x > y else (y if y > z else z))  # OR
    > x = y if y > z else z

--  MATCH/CASE   // no break instruction; not needed.
    > match boisson:
        case 1:
            #faire_cafe()
        case 2:
            #faire_cappuccino()
        case _:
            print("Boisson inconnue !")
    On combine en un seul cas avec le ou '|':
    > match mot:
        case "paradoxale"|"dichotomie":
    With numbers:
    > case 8|-8:
    With tuples or lists:
    > match(bool(a%2), bool(b%2)):
        case (False, False):   // Tuple.
    > match(player_input.split()):
        case ["go", "north"]:     // List.

--  To define an empty loop with WHILE:
    > while liste.pop() != 5:
          pass

--  WHILE and FOR peuvent être assortie d'une clause 'else', qui est exécutée à la fin de la boucle, sauf dans le cas d'une sortie avec 'break'.
    > while liste:
          ...
          break
      else:
          ...
--  'continue' termine l'itération courante mais reste dans la boucle.
--  'break' interrompt l'itération courante et sort également de la boucle.

EDITION
=======

--  To tell Python which encoding to use, insert a comment of the form # -*- coding: encoding name -*-
    as the first or second line of your program:
    > # -*- coding: utf-8 -*-

--  To multiline comment:
    > """
      """
--  To break a long line:
    -   Ending each line on the screen, other than the last one, with a backslash (\)
    -   Wrapping the whole line ith bracketing, i.e., parentheses, square brackets, and braces, and putting a '+'
        at the end of each piece of the line.

EXCEPTIONS
==========



EXECUTION (with INPUTS)
=======================

--  To run a program directly in the console:
    > python3 trash.py  // in the directory of trash.py
--  To run a selection of source code from the Pycharm editor in console:
    shortcut: ^ + SHIFT + E
--  To run file in console:
    > ^ + ENTER
--  To run a file .py in terminal:
    First line in file:
    #!/usr/bin/env python3
    Execute with:
    > python3 myname.py

--  To ask interactively a user to enter a value:
    >   nom_ville = input("Entrez le nom de la ville : ")
--  To run a program passing arguments to it:
    -- ArgumentParser from module argparse

FILES
=====

--  To read or (binary) write a file with context manager:
    > with open(r'C:\temp\spam.txt', 'r', encoding= 'utf8') as f:
        <bloc of instructions>
    > with open(r'C:\temp\spam.bin', 'bw') as f: // bw --> binary write.
--  To add the content to a file:
    > with open("foo.txt", "a", encoding='utf-8') as sortie:  // a --> add to the end.
--  Un fichier est son propre itérateur:
    > with open("foo.txt", encoding='utf-8') as entree:
          print(entree.__iter__() is entree)

--  To change the terminal stdout to a discretinary file:
    > import sys
    > autre_stdout = open('ma_sortie.txt', 'w', encoding='utf-8')

--  Built-in function 'repr':
    > lines = "abc" + "\n" + "def"  + "\n"
    > print(repr(lines))  // --> 'abc\ndef\n'

--  To manipulate paths:
    > from pathlib import Path
    > path = Path("files/myfile.txt")
--  To find all json files in a dir:
    > dirpath = Path('./data/')
    > for json in dirpath.glob("*.json"): ...

FUNCTIONS
=========

--  Lambdas:
    lambda <sequence of variable names> : <expression>
    lambda x, y: x*y
--  To define an empty function:
    > def foo():
          pass

--  Pour typer les paramètres et le retour d'une fonction:
    > def fact(n : int) -> int:
          return 1 if n <= 1 else n * fact(n-1)
    > def foo(x: List[int]) -> List[str]:
          pass
    > ConnectionOptions = Dict[str, str]
      Address = Tuple[str, int]
      Server = Tuple[Address, ConnectionOptions]
    > def partially_typed(n1: int, n2: Any) -> Any: // partially typing.
          return None

--  Default values in the signature of a function are shared betweeb objects returned by the function.

HELP
====

--  In ipython and notebook:
    >str?  // p.e.
--  To get interactive help in the console:
    > help()
    To exit:
    > quit
--  To get help about a particular function:
    > help(nameFunction)
    > help(math.ceil)  // function in module math
--  To get help about a method:
    > help(list.sort)


MODULES/SPACE-NAMES
===================

Un module est donc un objet python qui correspond à la fois à :
--  Un (seul) fichier sur le disque ;
--  Un espace de nom pour les variables du programme.

--  To  import a module:
    > import math
    > import monmodule as autremodule   // changing the name of the module
    > from monmodule import monsymbole as autresymbole   // changing the name of a module attribute.
    > from un_deux_trois_quatre import un as one, deux, trois as three  // resultant names = one(), deux(), three()
    > import foo // définit une variable 'foo' qui désigne un module.
    > import foo as bar   //  a le même effet, sauf que le module est accessible par la variable 'bar'.
    > from foo import var // définit une variable 'var' qui désigne un attribut du module.
    > from foo import var as newvar  // définit une variable newvar qui désigne ce même attribut.

    > from importlib import import_module
    > imported_modtools = import_module('mod' + 'tools')  // Ces deux lignes sont equivalentes à :
    > import modtools

--  To see the functions in a module
    > dir(math)

BUILTINS
--  Module directly accesible: 'builtins'
    > import builtins
    > dir(builtins)
    --  After changing the definition of a builtin function/variable, to reestablish its original meaning:
        > print = builtins.print   // after print = 1, p.e.

--  La variable 'sys.builtin_module_names' contient le nom des modules qui sont implémentés en C et font partie intégrante de l'interpréteur.

LOCAL SCOPE
--  To see the current scope's local variables in a dictionary data structure:
        > locals()
--  To delete variable in the current scope's local variables:
        > if 'i' in locals():
                del i
--  Une variable de boucle est définie (assignée) dans la boucle et reste visible une fois la boucle terminée.
--  Les variables de compréhension ne fuient pas.
--  Les arguments attendus par la fonction sont considérés comme des variables locales, c'est-à-dire dans l'espace de noms de la fonction.

GLOBAL VARIABLES
--  Comment fait-on alors pour modifier une variable globale depuis une fonction APRÈS l'avoir utilisée? Pour cela il faut utiliser l'instruction global:
    > variable5 = "globale"
      def ma_fonction5():
          global variable5
          print("dans la fonction", variable5)  // print 'globale'
          variable5 = "changée localement"

    No need to use 'globale' here because it has not been previously used:
    > variable4 = "globale"
      def ma_fonction4():
            variable4 = "locale"
            print(variable4)  // print 'locale'

--  La fonction 'globals' nous donne la liste des symboles définis au niveau de l'espace de noms du module dans lequel est définie la fonction.
    > globals() // inside the module.
--  The function vars() when executed inside a module is similar to globals.
--  The function vars(moduleName) is similar to globals(), but it is executed outside of the module (when imported).
--  La fonction 'locals' nous donne les variables locales qui sont accessibles à cet "endroit" du code.

RELOAD
--  Module importlib, fonction 'reload': elle permet de forcer le rechargement d'un module.
--  Il est possible de forcer le rechargement d'un module en l'enlevant de la variable 'sys.modules' (it is a dictionnary).

--  Pour charger vos propres modules ou packages, il suffit de les placer dans le répertoire où se trouve le point d'entrée:
    > from pathlib import Path
      Path.cwd()  // pour savoir le répertoire courant.

NUMBERS
=======

--  When a float is converted to an int, the number is truncated (not rounded).
--  Complex number:
    > 2 + 2j
    > 2 + 2.j
    > 2 + 2*1.j

OPERATORS
=========

--  '*' operator for iterable unpacking:
    Python vous autorise à mentionner une seule fois, parmi les variables qui apparaissent à gauche de une affectation, une variable précédée de '*'.
    Cette variable est interprétée comme une liste de longueur quelconque des éléments de la collection à gauche.
    > a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    > x, *y = a
    > y = [1, 2, 3, 4, 5, 6, 7, 8, 9]
    Conversely:
    > *x, y = a
    > x = [0, 1, 2, 3, 4, 5, 6, 7, 8]

--  i to the power j:
    > i ** j
--  Floor division:
    > i//j

--  Negative boolean 'not'
    > not mybooleanValue
--  Other operators of type bool: 'and', 'or'.
--  Intervals:
    > if bas <= x <= haut: ...

--  %timeit in the console to mesure the time of execution of an instruction.





