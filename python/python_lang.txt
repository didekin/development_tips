CHARACTERS
==========

--  To see the default encoding:
    > sys.getdefaultencoding()

CLASSES-OBJECTS ASSIGNMENTS
===========================

--  To define an empty class:
    > class Foo:
          pass

--  To know the type of an object:
    > type(object)
    > isinstance(23,int)
    > isinstance(myarg, (tuple, list))
--  L'opérateur 'is' permet de savoir si deux valeurs correspondent au même objet en mémoire.
    > a is b
    La fonction id() retourne un identificateur unique pour chaque objet; un modèle mental acceptable est celui d'adresse mémoire.
    (a is b)  ⟺  (id(a) == id(b))

--  Pour annuler la définition d'une variable:
    > del varname
    > del listname[2:10:3]  // liste
    > del d['a']  // dictionnaire
    > del listname[2:10:3], d['a']  // plusieurs arguments

--  Multiple assignment:
    > x, y = 2, 3
    > x, y = y, x
--  Pour affecter le même objet à plusieurs variables:
    > a = b= 'hola'
--  La sémantique de '+=' est différente suivant que l'objet référencé par le terme de gauche est mutable ou immuable.
    > a = b = [] // a += [1]  // print(a) --> [1], print(b) --> [1]
    > a = b = 1  // a += 1  // print(a) --> 2, print(b) --> 1

CONTROL FLOW
============

--  CONDITIONAL EXPRESSIONS: expr1 if condition else expr2  or <résultat_si_vrai> if <condition> else <résultat_si_faux>
    > print((x if x > z else z) if x > y else (y if y > z else z))  # OR
    > x = y if y > z else z

--  MATCH/CASE   // no break instruction; not needed.
    > match boisson:
        case 1:
            #faire_cafe()
        case 2:
            #faire_cappuccino()
        case _:
            print("Boisson inconnue !")
    On combine en un seul cas avec le ou '|':
    > match mot:
        case "paradoxale"|"dichotomie":
    With numbers:
    > case 8|-8:
    With tuples or lists:
    > match(bool(a%2), bool(b%2)):
        case (False, False):   // Tuple.
    > match(player_input.split()):
        case ["go", "north"]:     // List.

--  To define an empty loop with WHILE:
    > while liste.pop() != 5:
          pass

--  WHILE and FOR peuvent être assortie d'une clause 'else', qui est exécutée à la fin de la boucle, sauf dans le cas d'une sortie avec 'break'.
    > while liste:
          ...
          break
      else:
          ...
--  'continue' termine l'itération courante mais reste dans la boucle.
--  'break' interrompt l'itération courante et sort également de la boucle.

EDITION
=======

--  To tell Python which encoding to use, insert a comment of the form # -*- coding: encoding name -*-
    as the first or second line of your program:
    > # -*- coding: utf-8 -*-

--  To multiline comment:
    > """
      """
--  To break a long line:
    -   Ending each line on the screen, other than the last one, with a backslash (\)
    -   Wrapping the whole line ith bracketing, i.e., parentheses, square brackets, and braces, and putting a '+'
        at the end of each piece of the line.

EXCEPTIONS
==========



EXECUTION (with INPUTS)
=======================

--  To run a program directly in the console:
    > python3 trash.py  // in the directory of trash.py
--  To run a selection of source code from the Pycharm editor in console:
    shortcut: ^ + SHIFT + E
--  To run file in console:
    > ^ + ENTER

--  To ask interactively a user to enter a value:
    >   nom_ville = input("Entrez le nom de la ville : ")
--  To run a program passing arguments to it:
    -- ArgumentParser from module argparse

FILES
=====

--  To read or (binary) write a file with context manager:
    > with open(r'C:\temp\spam.txt', 'r', encoding= 'utf8') as f:
        <bloc of instructions>
    > with open(r'C:\temp\spam.bin', 'bw') as f: // bw --> binary write.
--  To add the content to a file:
    > with open("foo.txt", "a", encoding='utf-8') as sortie:  // a --> add to the end.
--  Un fichier est son propre itérateur:
    > with open("foo.txt", encoding='utf-8') as entree:
          print(entree.__iter__() is entree)

--  To change the terminal stdout to a discretinary file:
    > import sys
    > autre_stdout = open('ma_sortie.txt', 'w', encoding='utf-8')

--  Built-in function 'repr':
    > lines = "abc" + "\n" + "def"  + "\n"
    > print(repr(lines))  // --> 'abc\ndef\n'

--  To manipulate paths:
    > from pathlib import Path
    > path = Path("files/myfile.txt")
--  To find all json files in a dir:
    > dirpath = Path('./data/')
    > for json in dirpath.glob("*.json"): ...

FUNCTIONS
=========

--  Lambdas:
    lambda <sequence of variable names> : <expression>
    lambda x, y: x*y
--  To define an empty function:
    > def foo():
          pass

--  Pour typer les paramètres et le retour d'une fonction:
    > def fact(n : int) -> int:
          return 1 if n <= 1 else n * fact(n-1)
    > def foo(x: List[int]) -> List[str]:
          pass
    > ConnectionOptions = Dict[str, str]
      Address = Tuple[str, int]
      Server = Tuple[Address, ConnectionOptions]
    > def partially_typed(n1: int, n2: Any) -> Any: // partially typing.
          return None

--  Default values in the signature of a function are shared betweeb objects returned by the function.

HELP
====

--  In ipython and notebook:
    >str?  // p.e.
--  To get interactive help in the console:
    > help()
    To exit:
    > quit
--  To get help about a particular function:
    > help(nameFunction)
    > help(math.ceil)  // function in module math
--  To get help about a method:
    > help(list.sort)


MODULES/SPACE-NAMES
===================

--  To  import a module:
    > import math
--  To see the functions in a module
    > dir(math)

BUILTINS
--  Module directly accesible: 'builtins'
    > import builtins
    > dir(builtins)
    --  After changing the definition of a builtin function/variable, to reestablish its original meaning:
        > print = builtins.print   // after print = 1, p.e.

LOCAL SCOPE
--  To see the current scope's local variables in a dictionary data structure:
        > locals()
--  To delete variable in the current scope's local variables:
        > if 'i' in locals():
                del i
--  Une variable de boucle est définie (assignée) dans la boucle et reste visible une fois la boucle terminée.
--  Les variables de compréhension ne fuient pas.
--  Les arguments attendus par la fonction sont considérés comme des variables locales, c'est-à-dire dans l'espace de noms de la fonction.

GLOBAL VARIABLES
--  Comment fait-on alors pour modifier une variable globale depuis une fonction APRÈS l'avoir utilisée? Pour cela il faut utiliser l'instruction global:
    > variable5 = "globale"
      def ma_fonction5():
          global variable5
          print("dans la fonction", variable5)  // print 'globale'
          variable5 = "changée localement"

    No need to use 'globale' here because it has not been previously used:
    > variable4 = "globale"
      def ma_fonction4():
            variable4 = "locale"
            print(variable4)  // print 'locale'

--  La fonction 'globals' nous donne la liste des symboles définis au niveau de l'espace de noms du module.
    Il s'agit évidemment du module dans lequel est définie la fonction.
--  La fonction 'locals' nous donne les variables locales qui sont accessibles à cet "endroit" du code.

NUMBERS
=======

--  When a float is converted to an int, the number is truncated (not rounded).
--  Complex number:
    > 2 + 2j
    > 2 + 2.j
    > 2 + 2*1.j

OPERATORS
=========

--  '*' operator for iterable unpacking:
    Python vous autorise à mentionner une seule fois, parmi les variables qui apparaissent à gauche de une affectation, une variable précédée de '*'.
    Cette variable est interprétée comme une liste de longueur quelconque des éléments de la collection à gauche.
    > a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    > x, *y = a
    > y = [1, 2, 3, 4, 5, 6, 7, 8, 9]
    Conversely:
    > *x, y = a
    > x = [0, 1, 2, 3, 4, 5, 6, 7, 8]

--  i to the power j:
    > i ** j
--  Floor division:
    > i//j

--  Negative boolean 'not'
    > not mybooleanValue
--  Other operators of type bool: 'and', 'or'.
--  Intervals:
    > if bas <= x <= haut: ...

--  %timeit in the console to mesure the time of execution of an instruction.

PRINTING
========

--  print(...) insert the spaces betweeen the arguments passed.
--  print(...) by default insert a new line character at the end of the arguments. To avoid this, an 'end' argument can be passed.

--  To inline variables in text:
    >   print(f"hello, {expression}")  # The expression can be result of calling a function.
        On peut ajouter le f devant toutes les formes de strings, qu'ils commencent par ' ou " ou ''' ou """.
    > print ("Add 10 to 12 and 14, and get %s and %s" % (twentytwo, twentyfour)) # twentytwo, twentyfour are vars. The final % is the operator.
    > print("log(x): ", pylab.log(x))

--  To include a curly brace in the string denoted by an f-string use two braces:
    > print(f'{{{3*5}}}')   # prints {15}.
--  The expression inside an f-string can contain modifiers that control the appearance of the output string.
    These modifiers are separated from the expression denoting the value to be modified by a colon (:).
    > f'{3.14159:.2f}'  # evaluates to '3.14'
    Pour forcer un petit entier à s'afficher sur 4 caractères, avec des 0 ajoutés au début si nécessaire:
    >   f"{x:04d}"  // if x = 15, then print(f"{x:04d}") -> '0015'
    Pour n'obtenir que l'heure et la minute d'un objet datetime:
    >   f"{mtime_datetime:%H:%M}"

--  To print a number with a ',' thousand separator: (problems with a . separator)
    > print(f"z:,")  # z is a float number.

REGULAR EXPRESSIONS
===================

--  Module re
    >   import re
--  Pour savoir si un objet chaine est ou non de la forme *-*.txt
    >   regexp = "(.*)-(.*)\.txt"
--  re.match(regexp, sample)  ⟺  re.compile(regexp).match(sample)

--  Pour chercher tous les mots se terminant par 'a' ou 'm' dans une chaîne:
    >   print(re.findall(r"\w*[am]\W", sentence))
--  L'attrape-tout '.' en fait n'attrape pas le caractère de fin de ligne \n. Il existe un flag re.DOTALL qui permet de
    faire de '.' un vrai attrape-tout qui capture aussi les newline
    Or pour l'ajouter explicitement:
    > match = re.compile("([\w \n]*)", flags=re.UNICODE).match(sample)

GROUPS
--  Pour l'accès par rang aux groups, les indices commencent à 1.
--  (...) les parenthèses définissent un groupe anonyme.
--  (?P<name>...) définit un groupe nommé
--  (?:...) permet de mettre des parenthèses mais sans créer un groupe.
--  (?P=name) ne matche que si l'on retrouve à cet endroit de l'entrée la même sous-chaîne que celle trouvée pour le groupe name en amont.
--  Pour ajouter comme contrainte que le premier et le dernier groupes de chiffres soient identiques:
    >   regexp3 = "(?P<id>[0-9]+)[A-Za-z]+(?P<needle>[0-9]+)[A-Za-z]+(?P=id)"

STRINGS
=======

--  To concatenate string varibles with spaces in between:
    > print(var1,var2)<
--  To concatenate without spaces:
    > print(var1 + var 2)
    > "abc"  "def" // quand deux chaînes apparaissent immédiatement l'une après l'autre sans opérateur, elles sont concaténées.
    > print(f"pour n = {test:2d} : premier → {premier(test)}\n"
          f" premier_sans_else → {premier_sans_else(test)}\n")
--  To repeat a string a number of times
    > varstringA * number   // "hola" * 5

--  To cast a number, p.e., to a string:
    > str(5)

--  Negative numbers are used to index from the end of a string.
    > 'abc'[‐1] # is 'c'.
--  To reverse a string with all its characters:
    > varstring[::-1]
--  The expression 'abc'[:] is semantically equivalent to 'abc'[0:len('abc')]

--  To check if a sequence of characters is a string:
    > "def" in "abcdefcdefghefghijk"
--  To iterate over characters of a string:
    > for ch in 'ad123fg': ...





