VECTORS - ARRAYS
================

--  Indexes start counting from 1.

CREATION

--  > x = [ -1.1, 0.0, 3.6, -7.2 ]   # commas
--  > y = [ -1.1; 0.0; 3.6; -7.2 ]  # semicolons
    Elements of vectors are one-dimensional array.
--  However, array of 4 elements: x = [ -1.1 0.0 3.6 -7.2]

--  To create a zero vector of dimension n:
    > zeros(n)
--  For a vector of ones:
    > ones(n)
--  To create an array of 4 vectors with 3 zero elements:
    > arr_zeros = [zeros(3) for j = 1:4]
--  To create a unit vector (Ei) with a function:
    > unit_vector(i,n) = [zeros(i-1); 1 ; zeros(n-i)]  # this is an inline function.
    > unit_vector(a,b)  # create 1 in index a in a vector with length b.

--  To create a copy of a vector:
    > y = copy(x)
--  To assign values to a range of indexes:
    > x[i:j] = [val1, val2, ]

--  To reverse a vector:
    > z[end:-1:1]
--  To create a vector of succesive differences of the elements of a vector:
    > d = x[2:end] - x[1:end-1]

--  To concatenate vectors with scalars:
    > z = [1;x;2]
--  To concatenate vectors in a single vector:
    > z = [x;y]  // where x and y are vectors.
    > OR z = vcat(x,y)
--  To create an array whose elements are vectors (an array of vectors):
    > z = [x,y]  # attention to the comma. z = [x y] is a 4x2 array (four rows with 2 elements each)
--  To create a tuple or a list of vectors:
    > l = (x,y)

--  To generate a random vector of length n with entries that are between 0 and 1:
    > rand(n)
--  From a normal distribution:
    > randn(n)

Sparse vectors

--  package SparseArrays

--  To create a vector with non-zero elements in two indexes, with 10^6 elements:
    > a = sparsevec( [i,j], [1.0, -1.0], 10^6)
--  To create a sparse vector of a non-sparse one:
    > sparse(x)
--  To see the number of non-zero elements:
    > nnz(sx)

SUBSETTING

--  Last element of a vector: x[end] OR x[length(x)]
--  To subset the values between two indexes:
    > x[i:j]
--  To subset 'jumping':
    > x[i:jumpsize:j]  // where jumpsize is the increment between succesive indexes between the range.
--  To extract a vector of an array or a tuple of vectors:
    > l[indexVector]  // we obtain a vector.
--  To extract a component of vector in an array or list of vectors:
    > l[indexVector][indexComponent]

SUBSETTING AND OPERATIONS

--  To subset with elementwise function:
    > x[abs.(x) .> 1]
--  To sum a subset (elements 6:19):
    > sum(x[6:19])
--  To select the nearest vector to x in a z set of vectors:
    > z[argmin([norm(x-y) for y in z])];

OPERATIONS

--  Vector equality: ==
--  Scalar vector multiplication:
    > scalar * vector
--  Scalar vector division:
    > vector / scalar
    > scalar \ vector  # same result in both lines.
--  Elementwise operations between vectors of same length:
    > x .== y # equality of components.
    Similar with .>, .<, .>=, ....
    > x .* y
    > x ./ y  # elements of x divided by elements of y.
    > x .\ y  # elements of y divided by elements of x.
    > x .^ y
--  Elementwise operations with scalars:
    > v .+ scalar
    > v .- scalar
    > v .^ scalar # elements of v to the power a.
    > scalar .^ v # a to the power of the different elements of v.

--  Elementwise function:
    > sin .(x) # returns a vector with the sin of each element of x.
    > abs.(x) .>= scalar # returns a vector with 1 (true) or 0 (false) with as many elements as x.
--  Elementwise assingment to the same value:
    > x[2:3] .= scalar

--  Linear combination function:
      function lincomb(coeff, vectors)
          return sum( coeff[i] * vectors[i] for i = 1:length(vectors) )
      end
--  Inner product:
    > x' * y
--  Norm:
    > norm(v)
--  Root mean square:
    > rms(x) = norm(x) / sqrt(length(x));
--  Chebyshev bound function
    > cheb_bound(x,a) = floor(norm(x)^2/a^2);
--  Distance between two vectors:
    > norm(u-v)
--  Nearest neighbour function:
    > nearest_neighbor(x,z) = z[argmin([norm(x-y) for y in z])];

--  To substract the mean from every element of a vector:
    > de_mean(x) = x .- mean(x);
--  Standard deviation function:
    > stdev(x) = norm(x .- avg(x))/sqrt(length(x));
--  Function to standardize vectors:
    > function standardize(x)
        x_demean = de_mean(x)
        return x_demean/rms(x_demean)
      end
--  Function for angle (in radians) between two vectors:
    > ang(x,y) = acos(x'*y/(norm(x)*norm(y)));
--  Smallest angle with vectors in a set:
    > smallest_ang(x,z) = z[argmin([ang(x,y) for y in z])];
--  Correlation function:
    > function correl_coeff(u,v)
        u_demean = de_mean(u)
        v_demean = de_mean(v)
        return (u_demean'*v_demean)/(norm(u_demean)*norm(v_demean))
      end

# Gram-Schmidt algorithm
function gram_schmidt(arrVectors, tol = 1e-10)
    # array of orthonormal vectors
    q = []
    for i = 1:length(arrVectors)
        q_tilde = arrVectors[i]
        for j = 1:i-1
            q_tilde -= (q[j]' * arrVectors[i]) * q[j]
        end
        if (norm(q_tilde) < tol)
            return
        end
        push!(q, q_tilde/norm(q_tilde))
    end;
    return q
end

EXAMPLES

--  A vector of discount factors to calcualte NPV:
    > r = 0.05; # 5% per-period interest rate
    > d = (1+r) .^ -(0:n-1)
