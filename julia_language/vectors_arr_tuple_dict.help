VECTORS - ARRAYS
================

--  Indexes start counting from 1

CREATION

--  > x = [ -1.1, 0.0, 3.6, -7.2 ]   # commas   4-element Array{Float64,1}
--  > y = [ -1.1; 0.0; 3.6; -7.2 ]  # semicolons  4-element Array{Float64,1}
--  > v = collect(Float64, 3:-1:1)  # 3-element Array{Float64,1}
--  > v = collect(1:2:13)  # 7-element Array{Int64,1}
--  However, 1 x 4 array (2 dimensions): x = [-1.1 0.0 3.6 -7.2]  # 1Ã—4 Array{Float64,2}

--  To create a zero vector of dimension n:
    > zeros(n)
--  For a vector of ones:
    > ones(n)
--  To create an array of 4 vectors with 3 zero elements:
    > arr_zeros = [zeros(3) for j = 1:4]
--  To create a unit vector (Ei) with a function:
    > unit_vector(i,n) = [zeros(i-1); 1 ; zeros(n-i)]  # this is an inline function.
    > unit_vector(a,b)  # create 1 in index a in a vector with length b.
--  To fill the array A with all values as x:
    > fill!(A, x)
--  To create a copy of a vector:
    > y = copy(x)
--  To assign values to a range of indexes:
    > x[i:j] = [val1, val2, ]
--  To create a vector with repeated elements:
    > repeat(...)  # see docs for string and numeric values.

--  To create vectors by COMPREHENSION:
    > A1 = [sqrt(i) for i in [16,25,64]]   # 3-element Array{Float64,1}
    > A2 = [i^2 for i in [1,2,3]]   # 3-element Array{Int64,1}

--  To reverse a vector:
    > z[end:-1:1]
--  To create a vector of succesive differences of the elements of a vector:
    > d = x[2:end] - x[1:end-1]

--  To concatenate vectors with scalars:
    > z = [1;x;2]
--  To concatenate vectors in a single vector:
    > z = [x;y]  // where x and y are vectors.
    > z = vcat(A1, A2) # concatenates arrays vertically, i.e., stacks A1 on top of A2.
    > z = hcat(A1, A2) # concatenates arrays horizontally, i.e., adds A2 to the right of A1.
--  To create an array whose elements are vectors (an array of vectors):
    > z = [x,y]  # attention to the comma. z = [x y] is a 4x2 array (four rows with 2 elements each)
--  To create a tuple or a list of vectors:
    > l = (x,y)

--  To generate a random vector of length n with entries that are between 0 and 1:
    > rand(n)
--  From a normal distribution:
    > randn(n)

Sparse vectors

--  package SparseArrays

--  To create a vector with non-zero elements in two indexes, with 10^6 elements:
    > a = sparsevec( [i,j], [1.0, -1.0], 10^6)
--  To create a sparse vector of a non-sparse one:
    > sparse(x)
--  To see the number of non-zero elements:
    > nnz(sx)

SUBSETTING

--  Last element of a vector: x[end] OR x[length(x)]
--  To subset the values between two indexes:
    > x[i:j]
--  To subset 'jumping':
    > x[i:jumpsize:j]  // where jumpsize is the increment between succesive indexes between the range.
--  To extract a vector of an array or a tuple of vectors:
    > l[indexVector]  // we obtain a vector.
--  To extract a component of vector in an array or list of vectors:
    > l[indexVector][indexComponent]

SUBSETTING AND OPERATIONS

--  To subset with elementwise function:
    > x[abs.(x) .> 1]
--  To sum a subset (elements 6:19):
    > sum(x[6:19])
--  To select the nearest vector to x in a z set of vectors:
    > z[argmin([norm(x-y) for y in z])];

ORDER

--  To sort in decreaing order:
    > sort(vectorNm, rev = true);

OPERATIONS

--  Vector equality: ==
-- To transpose a vector:
    > vectorNm'
--  Scalar vector multiplication:
    > scalar * vector
--  Scalar vector division:
    > vector / scalar
    > scalar \ vector  # same result in both lines.
--  Elementwise operations between vectors of same length:
    > x .== y # equality of components.
    Similar with .>, .<, .>=, ....
    > x .* y
    > x ./ y  # elements of x divided by elements of y.
    > x .\ y  # elements of y divided by elements of x.
    > x .^ y
--  Elementwise operations with scalars:
    > v .+ scalar
    > v .- scalar
    > v .^ scalar # elements of v to the power a.
    > scalar .^ v # a to the power of the different elements of v.

--  Elementwise function:
    > sin .(x) # returns a vector with the sin of each element of x.
    > abs.(x) .>= scalar # returns a vector with 1 (true) or 0 (false) with as many elements as x.
--  Elementwise assingment to the same value:
    > x[2:3] .= scalar

--  Linear combination function:
      function lincomb(coeff, vectors)
          return sum(coeff[i] * vectors[i] for i = 1:length(vectors))
      end
--  Inner product:
    > x' * y
--  Norm:
    > norm(v)
--  Root mean square:
    > rms(x) = norm(x) / sqrt(length(x));
--  Chebyshev bound function
    > cheb_bound(x,a) = floor(norm(x)^2/a^2);
--  Distance between two vectors:
    > norm(u-v)
--  Nearest neighbour function:
    > nearest_neighbor(x,z) = z[argmin([norm(x-y) for y in z])];

--  To substract the mean from every element of a vector:
    > de_mean(x) = x .- avg(x);
--  Standard deviation function:
    > stdev(x) = norm(x .- avg(x))/sqrt(length(x));
--  Function to standardize vectors:
    > function standardize(x)
        x_demean = de_mean(x)
        return x_demean/rms(x_demean)
      end
--  Function for angle (in radians) between two vectors:
    > ang(x,y) = acos(x'*y/(norm(x)*norm(y)));
--  Smallest angle with vectors in a set:
    > smallest_ang(x,z) = z[argmin([ang(x,y) for y in z])];
--  Correlation function:
    > function correl_coeff(u,v)
        u_demean = de_mean(u)
        v_demean = de_mean(v)
        return (u_demean'*v_demean)/(norm(u_demean)*norm(v_demean))
      end

# Gram-Schmidt algorithm
function gram_schmidt(arrVectors, tol = 1e-10)
    # array of orthonormal vectors
    q = []
    for i = 1:length(arrVectors)
        q_tilde = arrVectors[i]
        for j = 1:i-1
            q_tilde -= (q[j]' * arrVectors[i]) * q[j]
        end
        if (norm(q_tilde) < tol)
            return
        end
        push!(q, q_tilde/norm(q_tilde))
    end;
    return q
end

EXAMPLES

--  A vector of discount factors to calcualte NPV:
    > r = 0.05; # 5% per-period interest rate
    > d = (1+r) .^ -(0:n-1)

DICTIONARIES
=============

--  Associative collections consisting of a key-value pair.
--  > D0 = Dict()  # Dict{Any,Any} with 0 entries
--  > D2 = Dict{Integer, String}(1 => "red", 2 => "white")  # Dict{Integer,String} with 2 entries:  2 => "white"  1 => "red"
--  > wine = ["red", "white", "rose"]
    > wine_dict = Dict{Int,String}(i => wine[i] for i in 1:length(wine))  # Dict{Int64,String} with 3 entries: 2 => "white" 3 => "rose"  1 => "red"

--  To associate a new value with an existing key:
    > wine_dict[1] = "sparkling"
--  Two ways to add new entries:
    > wine_dict[4] = "bourdeaux"
    > get!(wine_dict, 4, "borgogne") # will not add the new entry if a value is already associated with the the key.
--  To delete entries by key:
    > delete!(wine_dict,4)

--  To coerce keys or values into arrays:
    >  collect(keys(wine_dict))
    > collect(values(wine_dict))

Subsetting

--  > wine_dict[2]
      > "white"
--  > get(wine_dict, 1, "unknown")  # "unknown" is the value returned here if the key is not in the dictionary.
      > "red"
--  > haskey(wine_dict, 2)
      > true
--  > getkey(wine_dict, 4, 999)  # 999 is the value returned here if the key is not in the dictionary.
      > 999

TUPLES
======

--  They are an abstraction of function arguments without the function.
--  Tuples can have any number of parameters, and they do not have field names.
--  Fields are accessed by their index, and tuples are defined using brackets () and commas.

--  > tup2 = ("Data", 2.5, "Science", 8.8)
