# Previousl, in REPL:  ] add https://github.com/VMLS-book/VMLS.jl
using Pkg
Pkg.add(["LinearAlgebra", "SparseArrays", "Plots"])
using LinearAlgebra, SparseArrays, Plots, VLMS

CREATION

--  Matrices are represented in Julia as 2- dimensional arrays.
    These are constructed by giving the elements in each row, separated by space,
    with the rows separated by semicolons.
    > A = [0 1 -2.3 0.1; 1.3 4 -0.1 0; 4.1 -1 0 1.7]
--  To get dimensions:
    > size(A)
    > size(A1) # rows
    > size(A2) # columns

--  To convert an array (or a tuple) of column vectors into a matrix:
    > a = [[1., 2.], [4., 5.], [7., 8.]]
    > A = hcat(a...)  # a 2 * 3 matrix.
    The ... operator in hcat(a...) splits the array a into its elements, i.e., hcat(a...) is the same as hcat(a[1], a[2], a[3]), which concatenates a[1], a[2], a[3] horizontally.
--  To convert an array (or a tuple) of row vectors into a matrix:
    > A = vcat(a...)  # a 3 * 2 matrix.
--  To stack matrices B,C,D and E use ';' and a space to do (horizontal) concatenation.
    > A = [B C ; D E]
--  To stack an identity matrix with the right dimensions horizontally:
    > [A I]
--  To stack an identity matrix with the right dimensions vertically:
    > [A ; I]
--  To add an identity matrix with the right dimensions to the entries in A:
    > A + I

--  > zeros(m,n) # a m * n zero matrix.
--  To create an n × n identity matrix:
    > 1.0 * Matrix(I,n,n)  # multiplying by 1.0 converts the matrix into one with numerical entries; otherwise it has Boolean entries.
--  > ones(m,n)
--  To construct the diagonal matrix with diagonal entries in the vector s:
    > diagm(0 => s)
--  To put the diagonal entries of the (possibly not square) matrix X into a vector:
    > diag(A)
--  To create a triangular matrix with elements above the diagonal equal to zero:
    > tril(ones(nrows, ncolumns))

--  To create a sparse matrix from three arrays that specify the row indexes, column indexes, and values of the nonzero elements:
    > A = sparse([nonzero row indexes],[nonzero column indexes],[values], nrows, ncolumns)
    > A = sparse([1,2,2,1,3,4], [1,1,2,3,3,4], [ -1.11, 0.15, -0.10, 1.17, -0.30, 0.13 ], 4, 5)
--  > nnz(A)  # number of nonzero entries.
--  To have the sparse version of a full matrix:
    > sparse(A)
--  To have the full matrix from a sparse one:
    > Array(sparseA)
--  To create a sparse m × n zero matrix:
    > spzeros(m,n)
--  To create a sparse n × n identity matrix:
    > sparse(1.0I,n,n)

--  To create a random m×n matrix with entries between 0 and 1
    > rand(m,n)
--  From a normal distribution:
    > randn(m,n)
--  To create a random sparse matrix ():
    > sprand(nrows,ncolumns,density)  # with entries between 0 and 1. density is nnz(A)/(nrows * ncolumns)
    > sprandn(m,n,d) # with entries that range over all numbers.
    > A = sprand(10000,10000,10^-7)

SUBSETTING

--  To get the i,j entry:
    > A[i,j]
--  To get entries in certain rows and columns:
    > A[1:2,3:4]  # entries in rows 1:2 and columns 3:4.
    > A[:, j]  # entries in column j.
    > A[2,:]   # second row.
--  To reverse the order of rows:
    > X[numberRows:-1:1,:]

OPERATIONS

--  A == B
--  A .== B   # creates a matrix whose entries are Boolean, depending on whether the corresponding entries of A and B are the same.
--  sum(A .== B)  # gives the number of entries that are equal.
--  Transpose: A'
--  > norm(A)  or  norm(A[:])  # Frobenius norm.

--  To add an identity matrix with the right dimensions to the entries in A:
    > A + I
--  A + B
--  A - B
--  Scalar multiplication: scalar * A
--  Matrix vector multiplication: A * x

--  Elementwise operations (examples)
    > C = A .* B   # creates a matrix of the same size with elements Cij = AijBij.
    > Y = exp.(X)  # creates a matrix of the same size, with elements Yij = exp(Xij).

--  > difference_matrix(n) = [-eye(n-1) zeros(n-1)] + [zeros(n-1) eye(n-1)]; # eye is a function in VLMS
    --  Sparse version:
    > difference_matrix(n) = [-speye(n-1) spzeros(n-1)] + [spzeros(n-1) speye(n-1)];  # speye is a function in VLMS.

# Vandermonde Matrix
function vandermonde(t,n)
    # t is m-vector with elements t1, . . . , tm
    m = length(t)
    # matrix with m rows and n columns. n-1 is the maximum degree polynomial.
    V = zeros(m,n)
    for i=1:m
        for j=1:n
            # Row for the powers of the i-th value of vector t. The first value is always 1.
            V[i,j] = t[i]^(j-1)
        end
    end
    return V
end

OR:
# The ... operator in hcat(a...) splits the array a into its elements. hcat stacks horizontally the m-vectors t.^i.
vandermonde(t,n) = hcat([t.^i for i = 0:n-1]... )
