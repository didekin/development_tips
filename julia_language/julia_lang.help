PACKAGES
========

--  To add a package:
    > using Pkg
    > Pkg.add(["LinearAlgebra", "Clustering"])
--  To use a package in a script (written at the beginning):
    - using LinearAlgebra, SparseArrays, VMLS
    - (Or) import LinearAlgebra (in this case, functions must be called with:) LinearAlgebra.myfunction
      - In this case, an alias for the package can be created with: const alg = LinearAlgebra.
        (Reference to the function:) alg.myfunction
      - To statically import a function:
        import LinearAlgebra: myFunction
        (And then:) myFunction() (without package name or alias)

--  To include code in another file:
    - include("myFile.jl")

TYPES
=====

--  To check the type of a variable:
    > typeof(variableName)
--  As a general rule, primitive types such as Int64 or Float32 are immutable. The same goes for composite types defined using the struct keyword.
    An exception to this is for composite types that are explicitly defined as mutable struct.
    > isimmutable(varName)

NUMERIC

--  To display the architecture type of a computer:
    > Sys.WORD_SIZE
--  Max and min values of a numeric primitive:
    > typemax(Int64)
    > typemin(Int64)

Floats

--  Three components:
    --  a signed integer whose length determines the precision (the significand).
    --  the base used to represent the number (usually base 10).
    --  a signed integer that changes the magnitude of the floating point number (the exponent)
--  Inf # positive infinity.
    > isinf(1/0)
--  -Inf # negative infinity.
    > isinf(-11/0)
--  NaN  # not a number.
    > isnan(0/0)
--  Machine epsilon, an upper-bound on the rounding error in floating point arithmetic:
    > eps()

BOOLEAN

--  Boolean values are 8-bit integers.

STRINGS

--  A string is a sequence of Unicode code points, using UTF-8 encoding.
    String is the built-in type for strings and string literals.
    Strings are defined by double (or triple) quotes.
--  Char is a numeric value representing a Unicode code point. Char is the built-in type used to represent single characters.

--  To concatenate strings:
    $ string1 * string2
    > string("Yes.", " Sure is :)")
--  To concatenate the same string a number of times:
    $ string1 ^ numberOftimes
--  To generate a new string that is the original string str repeated n times:
    > repeat(str, n)

--  String interpolation takes place when a string literal is defined with a variable inside its instantiation. The variable is prepended with $.
    > "1 + 2 = $(1 + 2)"  # "1 + 2 = 3"

--  Substrings:
    > my_string[4:6] # indexes included
    > my_string[end] # last character
    --  To return the indices of the characters in the string str matching the pattern pat:
        > findfirst(pat, str)
    --  To check true/false depending on the presence/absence of substr in str.
        > occursin(substr, str)

--  To search string str for the pattern ptn and, if it is present, replaces it with rep:
    > replace(str, ptn => rep)

--  Regular expressions are defined as strings with a leading r outside the quotes.
    > occursin(r"[a-zA-Z0-9]$", str)
--  To return true/false if the regex has a match in the string str.
    > occursin(regex, str)
--  To return the first match of regex in the string. If there is no match, it returns the special Julia value nothing.
    > match(regex, str)
--  To return all the matches of regex in the string str as an array.
    > eachmatch(regex, str)
    > collect(eachmatch(r"[^a-zA-Z0-9]", str))

FUNCTIONS
=========

--  A function is an object that takes argument values as a tuple and maps them to a return value.
--  Functions with ! at the end of their names modify their arguments instead of copying them.

--  To type de COMPOSITE OPERATOR 'âˆ˜' :
    > \circ + tab

--  Arguments after the ';' are keyword arguments the default values are evaluated from left-to-right.
    This allows keyword arguments to refer to previously defined keywords or arguments. Keyword arguments can have explicit types.
    > function mm_median(x, eps = 0.001; maxit = 25, iter::Int64=Int(floor(eps))) ..... end
    Another example with typed arguments:
    > times1c(y::Float64) = *(y, 1)

--  To define a function f(x), where x is a vector of at least 4 elements:
    > f_1(x) = x[1] + x[2] - x[4]^2
--  To define an addition function:
    > add(x,y) = x + y
    OR
        function add(x,y)
             return(x+y)
        end

--  To define an argument by default (always in the last positions):
    > add(x, y = 5) = x + y
    > add(12)  # returns 17.
--  When the function body contains one or more return keywords, it returns immediately when a return keyword is evaluated.
--  Anonymus function passed as an argument to the function map:
    >  b = map(h -> abs(h), v)
    OR still better:
    > b = map(abs, v)

BROADCAST

--  'broadcast' expands singleton dimensions in array arguments to match the corresponding dimension in the other array
    without using extra memory, and applies the given function elementwise.
--  Dotted operators such as .+ and .* are equivalent to broadcast calls.
--  There is also a 'broadcast!' function to specify an explicit destination (which can also be accessed in a fusing fashion
    by '.=' assignment).

CONTROL FLOW
============

--  Chain
    >  b2 = (c = 20 ; d = 5 ; c * d)
        > 100

--  if-elseif-else
    if condition
            do
        elseif
            do
        else
            do
    end
    # OR
    if condition
        do
    else
        do
    end
    # OR
    a ? b : c

--  Loops

    --  Nested for loops can be written as a single outer loop with multiple indexing variables forming a Cartesian product,
        e.g., if there are two indexing variables then, for each value of the first index, each value of the second index is evaluated.

        > for i in str, j = 1:length(str)
            println((i, j))
          end

    --  When using variables defined outside the body of the loop, preappend them with the global keyword inside the body of the loop.

        > n=0
          x=1
          while x<10:
            global n
            n=n+1
          end

    --  To allow a loop to terminate early, before it has completed: break
    --  To move from the current iteration of a loop immediately into the next iteration before the current one is finished: continue
